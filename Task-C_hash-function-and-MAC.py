from cryptography.hazmat.primitives import hashes
from sympy import sieve
import random
import math
import binascii

#=====================================================
# Please do NOT modify the following code, but you are more than welcome to understand the code in detail

# Define a hash function class for Task C.
# The method get_hash_value(message) function return a hash value raning in [0, 365)
class HashFunctionTaskC:
    
    upper_bound = 1
    
    def __init__(self, upper_bound):
        self.upper_bound = upper_bound
    
    def get_hash_value(self, message = None):
        if(None==message):
            sys.exit("No message is given!")
            
        # Padding empty string
        if(len(message) == 0):
            message = "0"
        
        hash_value = ord(message[0])
    
        # The hash value is generated by taking the product (modulo 365) of the ordinal numbers of characters at the positions indexed by prime numbers
        for i in sieve.primerange(len(message)):
            hash_value = (ord(message[i-1])*hash_value)%self.upper_bound
    
        return hash_value


# Implement the birthday attack for a hash function
def birthday_attack(message_space, hash_function):
    
    has_collision = False
    tried_hash_values = set()
    collision_pair_1 = -1
    collision_pair_2 = -1
    
    random_index_samples = random.sample(range(len(message_space)), len(message_space)); # Random sampling without replacement
    
    for i in range(len(message_space)):   
        hash_value_1 = hash_function.get_hash_value(message_space[random_index_samples[0]])
        tried_hash_values.add(hash_value_1)
        for j in range(1, len(random_index_samples)):
            hash_value_2 = hash_function.get_hash_value(message_space[random_index_samples[j]])
            if hash_value_1 == hash_value_2:
                has_collision = True
                collision_pair_1 = random_index_samples[0]
                collision_pair_2 = random_index_samples[j]
                break
            else:
                tried_hash_values.add(hash_value_2)
                    
        if has_collision:
            break
        random_index_samples = random.sample(random_index_samples[1:], len(random_index_samples[1:]))
    
    if has_collision:
        return len(tried_hash_values), collision_pair_1, collision_pair_2
    else:
        print("No collision is found!")
        return -1, -1, -1    

    
# Examples of using this hash function
hash_function = HashFunctionTaskC(upper_bound=365)

example_message = "Hellow World, COMP2300/6300!"
print("Example message is: ", example_message)
print("Hash value of example message is: ", hash_function.get_hash_value(example_message))

modified_example_message = "Hell0w World, COMP2300/6300!"
print("Modified example message is: ", modified_example_message)
print("Hash value of modified example message is: ", hash_function.get_hash_value(modified_example_message))
print("")

# Example of perform birthday attack
# We use each line of the plain text in Task B.2 as a message. Then, the whole text can be regarded as a set of messages.
# Note that you need to replace the plain text file name (i.e., to replace <YourStudentID> with your own ID) to execute the program correctly
message_list  = None
with open("<YourStudentID>_Task-B-2_plain-text.txt") as file:
    message_list = file.read().splitlines()

# Show the number of messages
print("Number of messages: ", len(message_list))

# Perform the birthday_attack to the hash function once. The upper bound of hash values are set as 365.
count, cp1, cp2 = birthday_attack(message_list, HashFunctionTaskC(upper_bound=365))
print("The number of examined hash values (NOT the number of examined messages) before the first collision: \n%i" %count)
print("Collided message 1: ", cp1)
print(message_list[cp1])
print("Collided message 2: ", cp2)
print(message_list[cp2])
print("")


#=====================================================
# Following area is for your to write or complete the code to achieve the answers to Task C

# Subtask C.1 (2 marks): Use the same setting as the example (i.e., the same hash function and the same message set from the same file "<YourStudentID>_Task-B-2_plain-text.txt").
# You are required to perform to the birthday attack multiple times (>=500), and calculate the average number of examined hash values before the first collision.
# Compare the empirical average number of examined hash values before the first collision with its theoretical value (i.e., sqrt(Pi/2*n), where n is the number of possible hash values) to check if the difference is significant.
# Report the following information as the answers to Task C.1 in the answer template:
# (1) the rounds of birthday attacks of your choice, (2) the empirical average number of examined hash values before the first collision, (3) the theoretical value, and (4) the explanation on the difference between the empirical value and the theoretical value.

# TODO: Your code to achieve the subtask above

# Subtask C.1
rounds = 500  # Number of birthday attacks
total_hash_values = 0

for _ in range(rounds):
    count, _, _ = birthday_attack(message_list, HashFunctionTaskC(upper_bound=365))
    total_hash_values += count

empirical_average = total_hash_values / rounds
theoretical_value = math.sqrt(math.pi / 2 * 365)

print("Subtask C.1 Results:")
print("Rounds of birthday attacks:", rounds)
print("Empirical average number of examined hash values before the first collision:", empirical_average)
print("Theoretical value:", theoretical_value)
print("Difference:", empirical_average - theoretical_value)
print("")





# Subtask C.2 (1 mark): Through understanding the construction of the hash function, you are requested to forge a message for a given message, i.e., to identify a second preimage.
# The given message is Line 6 in the file "<YourStudentID>_Task-B-2_plain-text.txt".
# The change should be minor with substitution of a few characters, and the modified version still produces the same hash value as the given message.
# Report (1) the forged message and (2) the explanation why the modification works as the answers to Task C.2 in the answer template.
print("Line 6 message: ", message_list[5])
print("Line 6 message hash value: ", hash_function.get_hash_value(message_list[5]))
print("")

# TODO: Your code to show how you obtain the forged message and check if it can produce the same hash value.




# Subtask C.3 (2 marks): Now, you are requested to employ MD5 to generate the hash values for the Line 6 message and the forged message (the same as in Task C.2)
# How to use MD5 to generate hash values can be found here: https://cryptography.io/en/latest/hazmat/primitives/cryptographic-hashes/#cryptography.hazmat.primitives.hashes.MD5.
# Compare the two hash values to see if they are equal to each other
# Report the following information as the answers to Task C.3 in the answer template:
# (1) the hash values of the two messages, (2) the percentage of the overlap between the two hash values at the bit level,
# and (3) which hash function has a stronger avalanche effect, MD5 or the hash function we defined above?

# TODO: Your code to generate hash values and calculate the percentage of the overlap between the two hash values


